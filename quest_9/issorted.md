# Квест IX. IsSorted

## Название файла (go)

```
issorted.go
```

---

## Что нужно сделать — Instruction

### Оригинал инструкции

Write a function `IsSorted()` that returns `true`, if the slice of `int` is sorted, otherwise returns `false`.

The function passed as an argument `func(a, b int)` returns:

* a positive `int` if the first argument is greater than the second,
* `0` if they are equal,
* a negative `int` otherwise.

### Перевод

Написать функцию `IsSorted`, которая принимает:

* функцию `f`, сравнивающую два числа:

  ```go
  f(a, b int) int
  ```

  * возвращает положительное число, если `a > b`;
  * возвращает `0`, если `a == b`;
  * возвращает отрицательное число, если `a < b`;

* срез `[]int`.

Функция должна вернуть `true`, если срез отсортирован (по возрастанию или убыванию), иначе — `false`.

Пример использования:

```go
compare := func(a, b int) int {
    return a - b
}

sorted := IsSorted(compare, []int{1, 2, 3, 4})
// sorted будет true
```

---

## Решение

```go
package piscine

// IsSorted проверяет, отсортирован ли срез a.
// Функция compare возвращает положительное число, если первый элемент больше второго,
// отрицательное, если меньше, и 0, если равны.
func IsSorted(compare func(a, b int) int, a []int) bool {
	asc := false // индикатор возрастания
	des := false // индикатор убывания

	for i := 1; i < len(a); i++ {
		result := compare(a[i-1], a[i]) // сравниваем текущий и предыдущий элемент

		if result > 0 {         // предыдущий элемент больше текущего
			if des {            // если уже были элементы, показывающие убывание
				return false    // срез не отсортирован
			}
			asc = true           // фиксируем возрастание
		} else if result < 0 {  // предыдущий элемент меньше текущего
			if asc {            // если уже были элементы, показывающие возрастание
				return false    // срез не отсортирован
			}
			des = true           // фиксируем убывание
		}
	}

	return true // если конфликтов не найдено, срез отсортирован
}
```

---

## Разбор решения

### Инструмент / элемент кода | Объяснение и назначение

| Элемент                                                     | Объяснение                                                                                                 |
| ----------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| **package piscine**                                         | Указывает, что файл принадлежит пакету `piscine`.                                                          |
| **func IsSorted(compare func(a, b int) int, a []int) bool** | Объявление функции. `compare` — функция сравнения двух чисел. `a` — срез чисел. Функция возвращает `bool`. |
| **asc, des := false**                                       | Флаги, указывающие, встречались ли элементы, показывающие возрастание или убывание.                        |
| **for i := 1; i < len(a); i++**                             | Перебираем элементы среза, начиная со второго (для сравнения с предыдущим).                                |
| **result := compare(a[i-1], a[i])**                         | Вызываем функцию сравнения для пары элементов.                                                             |
| **if result > 0 / < 0**                                     | Определяем направление сортировки: >0 — убывание, <0 — возрастание.                                        |
| **if des / asc { return false }**                           | Если встречается конфликт между направлениями, возвращаем `false`.                                         |
| **return true**                                             | Если конфликтов нет — срез отсортирован, возвращаем `true`.                                                |
| **Фигурные скобки**                                         | Определяют начало и конец тела функции и цикла.                                                            |

---

## ИТОГИ

### 1. Объявление функции

```go
func IsSorted(compare func(a, b int) int, a []int) bool
```

Функция:

* принимает функцию сравнения элементов;
* принимает срез `[]int`;
* возвращает `true`, если срез отсортирован, иначе `false`.

---

### 2. Логика проверки сортировки

1. Перебираем все пары соседних элементов.
2. Сравниваем их с помощью функции `compare`.
3. Фиксируем направление сортировки (`asc` или `des`).
4. Если встречается противоположное направление — срез не отсортирован.
5. Если конфликтов нет — возвращаем `true`.

---

### 3. Особенности

* Позволяет проверять как возрастание, так и убывание.
* Использует функцию сравнения, чтобы поддерживать разные правила сортировки.
* Пустой срез или срез из одного элемента считается отсортированным.

---

## Учебный материал

### Глоссарий

| Термин               | Объяснение                                                                    |
| -------------------- | ----------------------------------------------------------------------------- |
| **Функция**          | Завершённый фрагмент программы, выполняющий действие.                         |
| **Параметры**        | Данные, которые передаются функции.                                           |
| **Аргументы**        | Конкретные значения, переданные при вызове функции.                           |
| **Тип данных**       | Определяет, какие значения может хранить переменная (`int`, `bool`, `[]int`). |
| **Срез (slice)**     | Изменяемая коллекция элементов.                                               |
| **Цикл for**         | Позволяет перебрать элементы среза с индексами.                               |
| **Итерация**         | Один шаг цикла.                                                               |
| **Флаги (asc, des)** | Булевы переменные для отслеживания направления сортировки.                    |
| **return**           | Завершает функцию и возвращает значение.                                      |
| **Пакет (package)**  | Набор файлов и функций, объединённых по смыслу.                               |

---

## Заключение

Функция `IsSorted` позволяет проверить, отсортирован ли срез целых чисел, с помощью настраиваемой функции сравнения. Это полезно для реализации гибкой проверки сортировки по разным правилам, включая как возрастание, так и убывание.