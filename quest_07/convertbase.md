# Quest 7.7 ConvertBase

## Название файла Go
`convertbase.go`

---

## Условия задания 

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| Write a function that receives three arguments: | Напишите функцию, которая принимает три аргумента: |
| *`nbr`: A string representing a numberic value in a [base](https://simple.wikipedia.org/wiki/Base_(mathematics)).* | *`nbr`: строка, представляющая числовое значение в [системе счисления](https://ru.wikipedia.org/wiki/Числовой_разряд).* |
| *`baseFrom`: A string representing the base `nbr` it's using.* | *`baseFrom`: строка, представляющая используемую базу `nbr`.* |
| *`baseTo`: A string representing the base `nbr` should be represented in the returned value.* | *`baseTo`: строка, представляющая базу `nbr`, в которой должно быть представлено возвращаемое значение.* |
| *Only valid bases will be tested.* | *Будут проверены только допустимые базы.* |
| *Negative numbers will not be tested.* | *Отрицательные числа проверяться не будут.* |

---

Нужно написать функцию, которая **переводит число** `nbr` **из системы счисления** `baseFrom` **в систему счисления** `baseTo` и возвращает результат в виде строки.  
Функция должна корректно работать только с **положительными числами** и **валидными базами**.

---

### Пример

| Вход | Ход выполнения | Результат |
| -------------- | -------------------- | -------------- |
| `"101"` из `baseFrom = "01"` в `baseTo = "0123456789"` | Бинарное `101` = десятичное `5` | `"5"` |
| `"5"` из `baseFrom = "0123456789"` в `baseTo = "01"` | Десятичное `5` = двоичное `101` | `"101"` |
| `"1A"` из `baseFrom = "0123456789ABCDEF"` в `baseTo = "01234567"` | Шестнадцатеричное `1A` = десятичное `26` → восьмеричное `32` | `"32"` |
| `"zzz"` из `baseFrom = "abcdefghijklmnopqrstuvwxyz"` в `baseTo = "0123456789"` | В 36-ричной системе `zzz` = `46655` | `"46655"` |


---

## Решение

```go
package piscine

// ConvertBase переводит число из системы baseFrom в систему baseTo.
func ConvertBase(nbr, baseFrom, baseTo string) string {
	// Проверка на корректность баз
	if hasDuplicates(baseFrom) || hasDuplicates(baseTo) ||
		containsChar(baseFrom, '+') || containsChar(baseFrom, '-') ||
		containsChar(baseTo, '+') || containsChar(baseTo, '-') {
		return ""
	}

	// Переводим число nbr в десятичное значение
	number := 0
	baseFromLen := len(baseFrom)

	for i, digitRune := range nbr {
		digitValue := indexInBase(digitRune, baseFrom)
		if digitValue == -1 {
			return "" // символ не найден в базе
		}
		power := len(nbr) - 1 - i
		number += digitValue * RecursivePower(baseFromLen, power)
	}

	// Если число равно 0 — возвращаем первый символ целевой базы
	if number == 0 {
		return string(baseTo[0])
	}

	// Переводим десятичное число в целевую систему baseTo
	baseToLen := len(baseTo)
	resultRunes := []rune{}

	for number > 0 {
		remainder := number % baseToLen
		resultRunes = append(resultRunes, rune(baseTo[remainder]))
		number /= baseToLen
	}

	// Переворачиваем результат, чтобы получить правильный порядок цифр
	for i, j := 0, len(resultRunes)-1; i < j; i, j = i+1, j-1 {
		resultRunes[i], resultRunes[j] = resultRunes[j], resultRunes[i]
	}

	return string(resultRunes)
}

// indexInBase возвращает индекс символа в строке базы
func indexInBase(char rune, base string) int {
	for i, b := range base {
		if b == char {
			return i
		}
	}
	return -1
}

// hasDuplicates проверяет, есть ли повторяющиеся символы в базе
func hasDuplicates(base string) bool {
	seen := make(map[rune]bool)
	for _, r := range base {
		if seen[r] {
			return true
		}
		seen[r] = true
	}
	return false
}

// containsChar проверяет, есть ли в базе запрещённый символ
func containsChar(base string, char rune) bool {
	for _, r := range base {
		if r == char {
			return true
		}
	}
	return false
}
```

---

## Ключевые понятия

| **Инструмент / элемент кода** | **Объяснение и назначение** |
|-------------------------------|------------------------------|
| **Пакет (`package piscine`)** | Объявление пакета. Все функции внутри относятся к пакету, что позволяет использовать их в других файлах этого же пакета. |
| **Функция (`func ConvertBase(...)`)** | Главная функция, которая получает три аргумента — число в виде строки `nbr`, исходную систему счисления `baseFrom` и целевую систему `baseTo`. Возвращает число, переведённое в новую систему счисления. **Пример вызова:** `ConvertBase("1010", "01", "0123456789") => "10"` |
| **Функция `indexInBase(...)`** | Находит индекс символа (цифры) в строке базы `baseFrom`. Если символа нет в базе — возвращает `-1`. |
| **Функция `hasDuplicates(...)`** | Проверяет, есть ли в строке базы (`baseFrom` & `baseTo`) повторяющиеся символы (что делает базу недопустимой). |
| **Функция `containsChar(...)`** | Проверяет, есть ли запрещённые символы (`+` или `-`) в базе. |
| **Тип `rune`** | Представляет Unicode-символ. Используется, чтобы функция корректно работала не только с ASCII, но и с другими символами. |
| **Срез (`[]rune`)** | Динамический массив, в котором собираются символы результата перед преобразованием обратно в строку. |
| **Цикл `for`** | Основной инструмент для прохода по символам числа и для перевода из одной системы счисления в другую. |
| **Функция `RecursivePower`** | Используется для возведения числа в степень. Эта функция была создана в 4-м квесте (см. [ссылку на задание](../quest_04/recursivepower.md)). |

---

## Логика и пошаговый разбор кода

### 1. Объявление функции

```go
func ConvertBase(nbr, baseFrom, baseTo string) string {
```
Функция принимает:

- `nbr` — строка с числом (например, `"1011"`);
- `baseFrom` — строка с символами исходной базы (например, `"01"` — двоичная);
- `baseTo` — строка с символами целевой базы (например, `"0123456789"` — десятичная).

---

### 2. Проверка валидности баз
```go
if hasDuplicates(baseFrom) || hasDuplicates(baseTo) ||
	containsChar(baseFrom, '+') || containsChar(baseFrom, '-') ||
	containsChar(baseTo, '+') || containsChar(baseTo, '-') {
	return ""
}
```

- Проверяем, нет ли повторяющихся символов в базах.
- Проверяем, нет ли запрещённых символов (`+` или `-`).
- Если база некорректна — возвращаем пустую строку.

**Пример:**
```go
baseFrom := "011" // ошибка, т.к. '1' повторяется
```
→ функция вернёт пустую строку.

---

### 3. Перевод числа в десятичную систему
```go
number := 0
baseFromLen := len(baseFrom)

for i, digitRune := range nbr {
	digitValue := indexInBase(digitRune, baseFrom) // находим числовое значение символа в исходной базе
	if digitValue == -1 {
		return "" // если символ не найден — база и число не совпадают
	}
	power := len(nbr) - 1 - i  // вычисляем степень: старшие разряды имеют больший вес
	number += digitValue * RecursivePower(baseFromLen, power) // суммируем значение цифры с её весом
}
```

**Переменные и их назначение**

1. **`number := 0`**
   - **Что это:** переменная, в которую будет суммироваться итоговое десятичное значение числа.
   - **Для чего нужна:** хранит текущий результат перевода числа из `baseFrom` в десятичную систему.

2. **`baseFromLen := len(baseFrom)`**
   - **Что это:** длина строки исходной базы (количество уникальных символов в `baseFrom`).
   - **Для чего нужна:** используется как основание системы счисления при вычислении веса каждой цифры (`digitValue * baseFromLen^power`).

3. **`i`** (в `for i, digitRune := range nbr`)
   - **Что это:** индекс текущего символа в строке числа `nbr`.
   - **Для чего нужна:** нужен, чтобы вычислять степень (`power`) для взвешивания цифры в числе.

4. **`digitRune`**
   - **Что это:** текущий символ (руна) из строки `nbr`.
   - **Для чего нужна:** это символ, который мы переводим в его числовое значение в исходной базе.

5. **`digitValue := indexInBase(digitRune, baseFrom)`**
   - **Что это:** числовое значение текущей цифры в исходной базе.
   - **Для чего нужна:** нужно для перевода символа в число, чтобы использовать его в вычислении десятичного значения.
   - **Пример:** если `baseFrom = "choumi"` и `digitRune = 'u'`, то `digitValue = 3`.

6. **`power := len(nbr) - 1 - i`**
   - **Что это:** степень, в которую нужно возвести основание базы, чтобы правильно учесть позицию цифры.
   - **Для чего нужна:** старшие разряды имеют больший вес, младшие — меньший.
   - **Пример:** для числа `"1011"`: цифра `'1'` на позиции 0 → `power = 3`.

7. **`number += digitValue * RecursivePower(baseFromLen, power)`**
   - **Что это:** обновление переменной `number` суммированием взвешенной цифры.
   - **Для чего нужна:** эта строка реализует формулу перевода числа из любой системы в десятичную.

---

**Пример** (nbr = "uoi", baseFrom = "choumi"):

---

**Исходные данные:**
- `nbr = "uoi"`
- `baseFrom = "choumi"` → длина `baseFromLen = 6` (основание системы)
- Символы `baseFrom` с индексами:

| Символ | Индекс |
| ------ | ------ |
| c      | 0      |
| h      | 1      |
| o      | 2      |
| u      | 3      |
| m      | 4      |
| i      | 5      |

Цель: перевести `"uoi"` в десятичное число.

---

**Шаг 1:** инициализация
```go
number := 0
baseFromLen := 6
```

`number` — сумма всех цифр с учётом их весов, пока пустая.

---

**Шаг 2:** первый символ `"u"` (i = 0)
```go
digitRune = 'u'
digitValue = indexInBase('u', baseFrom) = 3
power = len(nbr) - 1 - i = 3 - 1 - 0 = 2
number += 3 * RecursivePower(6, 2) = 3 * 36 = 108
```

- Старший разряд имеет наибольший вес → 6²
- `number` теперь = 108

---

**Шаг 3:** второй символ `"o"` (i = 1)
```go
digitRune = 'o'
digitValue = indexInBase('o', baseFrom) = 2
power = len(nbr) - 1 - i = 3 - 1 - 1 = 1
number += 2 * RecursivePower(6, 1) = 2 * 6 = 12
```

- `number` теперь = 108 + 12 = 120

---

**Шаг 4:** третий символ `"i"` (i = 2)
```go
digitRune = 'i'
digitValue = indexInBase('i', baseFrom) = 5
power = len(nbr) - 1 - i = 3 - 1 - 2 = 0
number += 5 * RecursivePower(6, 0) = 5 * 1 = 5
```

- `number` теперь = 120 + 5 = 125

---

**Итог:**
```go
number = 125
```
То есть строка `"uoi"` в системе счисления `"choumi"` соответствует **десятичному числу `125`**.

---

### 4. Обработка нуля
```go
if number == 0 {
    return string(baseTo[0])
}
```
Если число равно нулю, результат всегда первый символ целевой базы.
**Пример**: `ConvertBase("0", "01", "0123456789") => "0"`

---

### 5. Перевод из десятичной системы в целевую
```go
baseToLen := len(baseTo)
resultRunes := []rune{}

for number > 0 {
	remainder := number % baseToLen // остаток от деления → индекс символа в целевой базе
	resultRunes = append(resultRunes, rune(baseTo[remainder])) // добавляем цифру в срез
	number /= baseToLen // уменьшаем число, делим на основание
}
```

**Переменные:**
1. **`baseToLen := len(baseTo)`**
   - `baseToLen` — это **длина строки, представляющей целевую систему счисления**.
   - Например, если `baseTo = "choumi"`, то `baseToLen = 6`.
   - Она нужна, чтобы знать основание системы, для вычисления остатка при переводе числа из десятичной системы.
2. **`resultRunes := []rune{}`**
   - Это **срез рун**, в котором мы будем собирать цифры числа в целевой системе счисления.
   - Используем `rune`, чтобы корректно работать с любыми символами, не только цифрами (например, для нестандартных алфавитов).
3. **`remainder := number % baseToLen`**
   - Остаток от деления числа на основание (`baseToLen`).
   - Он **определяет индекс символа в целевой базе**, который будет следующей цифрой в результате.
  
4. **`resultRunes = append(resultRunes, rune(baseTo[remainder]))`**
   - Добавляем цифру (символ из `baseTo`) в срез.
   - Так мы собираем число поразрядно с **конца** (от младшего разряда к старшему).
5. **`number /= baseToLen`**
   - Делим число на основание целевой системы.
   - Это **сдвигает число на один разряд**, чтобы в следующей итерации взять следующую цифру.
   - Цикл повторяется, пока число не станет нулём.

---

**Пример** (`number = 125`, `baseTo = "choumi"`):

---

**Исходные данные:**
- `number = 125`
- `baseTo = "choumi"` → длина `baseToLen = 6` (основание 6)
- Цель: перевести `125` в «систему счисления» с символами `"c", "h", "o", "u", "m", "i"`.

---

**Шаг 1**: инициализация
```go
resultRunes := []rune{}
baseToLen := 6
```

---

**Шаг 2**: первый цикл
```go
remainder = number % baseToLen = 125 % 6 = 5
```
- Остаток 5 → символ `baseTo[5] = 'i'`
- Добавляем в `resultRunes` → `resultRunes = ['i']`
- Делим число на основание: `number /= 6 → number = 125 / 6 = 20` (целочисленно)

---

**Шаг 3**: второй цикл
```go
remainder = number % baseToLen = 20 % 6 = 2
```
- Остаток 2 → символ `baseTo[2] = 'o'`
- Добавляем в `resultRunes` → `resultRunes = ['i', 'o']`
- Делим число на основание: `number /= 6 → number = 20 / 6 = 3`

---

**Шаг 4**: третий цикл
```go
remainder = number % baseToLen = 3 % 6 = 3
```
- Остаток 3 → символ `baseTo[3] = 'u'`
- Добавляем в `resultRunes` → `resultRunes = ['i', 'o', 'u']`
- Делим число на основание: `number /= 6 → number = 3 / 6 = 0` → цикл останавливается

---

**Шаг 5**: результат

Срез `resultRunes` содержит цифры в **обратном порядке**: `['i', 'o', 'u']`

---

### 6. Разворот результата
```go
for i, j := 0, len(res)-1; i < j; i, j = i+1, j-1 {
    res[i], res[j] = res[j], res[i]
}
```
Что функция делает на самом деле — **разворачивает срез (reverse)**.  
То есть он меняет порядок элементов с конца на начало:
- `i` идёт с начала (`0`)
- `j` идёт с конца (`len(resultRunes)-1`)
- пока `i < j`, элементы меняются местами (`res[i] ↔ res[j]`)

В результате срез `resultRunes` переворачивается в обратном порядке.

**Пример:** `'1101'` → `'1011'`.

---

### 7. Возврат готового результата
```go
return string(res)
```
Срез рун преобразуется обратно в строку и возвращается.

---

### 8. Функция `indexInBase()`
```go
func indexInBase(r rune, base string) int {
	for i, b := range base {
		if b == r {
			return i
		}
	}
	return -1
}
```

**Что делает функция:**
- Получает символ (`r`) и строку базы (`base`)
- Ищет, какой индекс в базе соответствует этому символу
- Если символ найден → возвращает индекс
- Если не найден → возвращает `-1` (это важно для проверки корректности числа в базе)

**Переменные:**
- `r` — текущий символ из числа (`nbr`), который нужно преобразовать в значение
- `base` — строка символов системы счисления
- `i` — индекс текущего символа в `base`
- `b` — символ в базе на текущей позиции

**Разбор**
```go
func indexInBase(r rune, base string) int {
```

- Объявляем функцию `indexInBase`, которая принимает:
  - `r` — символ (руну), которую ищем в базе;
  - `base` — строку с символами системы счисления.
- Возвращает `int` — индекс символа в базе, или `-1`, если символ не найден.

```go
    for i, b := range base {
```

- Проходим по каждому символу `b` в строке `base`.
- `i` — индекс текущего символа в базе.

```go
        if b == r {
            return i
        }
```

- Сравниваем текущий символ `b` с искомым `r`.
- Если совпадают — возвращаем индекс `i`. Это позиция символа в базе.

```go
    }
    return -1
```

- Цикл закончился, символ не найден → возвращаем `-1`.

**Пример работы:**
```go
indexInBase('o', "choumi") // вернёт 2
indexInBase('x', "choumi") // вернёт -1
```

---

### 9. Функция `hasDuplicates()`
```go
func hasDuplicates(base string) bool {
	seen := make(map[rune]bool)
	for _, r := range base {
		if seen[r] {
			return true
		}
		seen[r] = true
	}
	return false
}
```

**Что делает функция:**
- Проверяет, нет ли в строке базы повторяющихся символов
- Если символ встречается повторно → возвращает `true` (база недопустима)
- Если все символы уникальны → возвращает `false`

**Переменные:**
- `base` — строка символов базы
- `seen` — словарь (`map[rune]bool`), фиксирует, какие символы уже встречались
- `r` — текущий символ при обходе строки

**Разбор**
```go
func hasDuplicates(base string) bool {
```

- Объявление функции `hasDuplicates`, которая принимает строку `base` (символы системы счисления) и возвращает `bool` — есть ли повторяющиеся символы.

```go
    seen := make(map[rune]bool) 
```

- Создаём пустой словарь (`map`) с ключом типа `rune` и значением `bool`.
- Этот словарь будет хранить все символы, которые уже встречались в строке.
- **Почему `rune`?** Чтобы функция корректно работала с любыми символами Unicode, а не только с ASCII.

```go
    for _, r := range base {
```

- Проходим по каждому символу `r` в строке `base`.
- `_` — индекс символа, который нам здесь не нужен.

```go
        if seen[r] { 
            return true
        }
```

- Проверяем: встречался ли символ `r` раньше.
- Если `seen[r]` уже `true`, значит символ повторяется → база недопустима, возвращаем `true`.

```go
        seen[r] = true
```

- Если символ ещё не встречался, отмечаем его как встреченный.
- Теперь `seen[r]` = `true` → при следующем появлении этого символа мы поймаем повтор.

```go
    }
    return false
```

- Цикл закончился, повторов не найдено → возвращаем `false`.

---

### Пример работы функции
```go
hasDuplicates("0123456789") // false, все символы уникальны
hasDuplicates("011")         // true, символ '1' повторяется
```

**Примечание:**
- В Go `map` — это структура ключ → значение. Здесь ключ — символ (`rune`), значение — `bool`, который показывает, встречался ли символ раньше.
- Этот приём **универсальный для проверки уникальности элементов** в массиве, срезе или строке.
- [Документация по map в Go](https://pkg.go.dev/maps)

---

### 10. Функция `containsChar()`
```go
func containsChar(base string, char rune) bool {
	for _, r := range base {
		if r == char {
			return true
		}
	}
	return false
}
```

**Что делает функция:**
- Проверяет, содержит ли база запрещённый символ (`+` или `-`)
- Если символ найден → возвращает `true`
- Если нет → возвращает `false`

**Переменные:**
- `base` — строка символов базы
- `char` — символ, который ищем
- `r` — текущий символ при обходе строки

**Разбор**
```go
func containsChar(base string, char rune) bool {
```

- Объявляем функцию `containsChar`, которая принимает:
  - `base` — строку с символами системы счисления;
  - `char` — символ, который ищем.
- Возвращает `bool` — содержит ли база этот символ.

```go
    for _, r := range base {
```

- Проходим по каждому символу `r` в строке `base`.

```go
        if r == char {
            return true
        }
```

- Если текущий символ совпадает с `char` — база содержит этот символ, возвращаем `true`.

```go
    }
    return false
```

- Цикл закончился, символ не найден → возвращаем `false`.

**Пример работы:**
```go
containsChar("0123456789", '+') // false
containsChar("0123456789+", '+') // true
```

---

## Визуализация
### Пример 1
```go
ConvertBase("101011", "01", "0123456789")
```
1. **Исходное число:** `"101011"` (бинарное)
2. **Перевод в десятичное:**
```
1*2^5 + 0*2^4 + 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0
= 32 + 0 + 8 + 0 + 2 + 1
= 43
```
3. **Перевод в целевую базу** (десятичную):
```
43 % 10 = 3 → '3'
43 / 10 = 4
4 % 10 = 4 → '4'
4 / 10 = 0 → конец
```
4. **Собираем результат в обратном порядке:** ['3', '4'] → ['4', '3']

**Вывод:**
```go
ConvertBase("101011", "01", "0123456789") => "43"
```

---

### Пример 2
```go
ConvertBase("63", "0123456789", "01234567")
```
1. **Исходное число:** `"63"` (десятичное)
2. **Перевод в десятичное:**
```
6*10^1 + 3*10^0 = 60 + 3 = 63
```
3. **Перевод в целевую базу** (десятичную):
```
63 % 8 = 7 → '7'
63 / 8 = 7
7 % 8 = 7 → '7'
7 / 8 = 0 → конец
```
4. **Собираем результат в обратном порядке:** ['7', '7'] → ['7', '7']

**Вывод:**
```go
ConvertBase("63", "0123456789", "01234567") => "77"
```

---

### Пример 3
```go
ConvertBase("uoi", "choumi", "01")
```
1. **Исходная база:** `"choumi"` (индексы: `c=0`, `h=1`, `o=2`, `u=3`, `m=4`, `i=5`)  
**Исходное число:** `"uoi"`
2. **Перевод в десятичное:**
```
u → 3, o → 2, i → 5
число = 3*6^2 + 2*6^1 + 5*6^0 = 3*36 + 2*6 + 5 = 108 + 12 + 5 = 125
```
3. **Перевод в целевую базу** (десятичную):
```
125 % 2 = 1 → '1'
125 / 2 = 62
62 % 2 = 0 → '0'
62 / 2 = 31
31 % 2 = 1 → '1'
31 / 2 = 15
15 % 2 = 1 → '1'
15 / 2 = 7
7 % 2 = 1 → '1'
7 / 2 = 3
3 % 2 = 1 → '1'
3 / 2 = 1
1 % 2 = 1 → '1'
1 / 2 = 0 → конец
```
4. **Собираем результат в обратном порядке:** ['1', '0', '1', '1', '1', '1', '1'] → ['1', '1', '1', '1', '1', '0', '1']

**Вывод:**
```go
ConvertBase("uoi", "choumi", "01") => "1111101"
```

---

## Глоссарий

| **Термин** | **Понятное объяснение** |
|-------------|--------------------------|
| **Система счисления** | Способ записи чисел с помощью набора символов (базы). Пример: двоичная (`01`), десятичная (`0123456789`), шестнадцатеричная (`0123456789ABCDEF`). |
| **База (основание)** | Количество уникальных символов в системе счисления. У двоичной — 2, у десятичной — 10. |
| **Индекс символа** | Позиция символа в строке базы. Например, `'A'` в `"0123456789ABCDEF"` имеет индекс 10. |
| **Руна (`rune`)** | Целое число, представляющее Unicode-символ. Позволяет работать с любыми алфавитами. |
| **Возведение в степень** | Математическая операция a^b (например, 2^3 = 8), используется при переводе в десятичную систему. |
| **Модуль (`%`)** | Остаток от деления. Помогает находить цифры при переводе из десятичной в другую систему. |

---

## Заключение

Функция `ConvertBase` показывает:
- как переводить числа между системами счисления;
- как использовать циклы, условия и руны в Go;
- как разбивать задачу на мелкие логические шаги.

**Главное** — понять, что перевод числа между базами всегда идёт через **десятичную систему**:  
сначала в десятичную → потом в нужную.
