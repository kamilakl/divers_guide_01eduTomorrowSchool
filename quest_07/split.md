# Quest 7.6 Split

## Название файла Go
`split.go`

---
## Условия задания

| **Instruction** | **Перевод** |
|------------------|-------------|
| *Write a function that receives a string and a separator and returns a `slice of strings` that results of splitting the string `s` by the separator `sep`.* | *Напишите функцию, которая получает строку и разделитель и возвращает `срез строк`, который является результатом разбиения строки `s` по разделителю `sep`.* |

---
### Пример
-**ввод** s := "HelloHAhowHAareHAyou?" /таб fmt.Printf("%#v\n", piscine.Split(s, "HA"))
-**вывод** []string{"Hello", "how", "are", "you?"}

---
## Решение

```go
package piscine

// Функция Split делит строку s по разделителю sep
func Split(s, sep string) []string {
	// Если разделитель пустой, возвращаем строку как один элемент среза
	if sep == "" {
		return []string{s}
	}

	var result []string  // Срез для хранения частей строки
	var currentString string  // Строка для текущей части

	// Проходим по всем символам строки
	for i := 0; i < len(s); i++ {
		// Если нашли начало разделителя, добавляем текущую часть в результат
		if s[i:i+len(sep)] == sep {
			result = append(result, currentString)  // Добавляем текущую строку в срез
			currentString = ""  // Очищаем текущую строку
			i += len(sep) - 1  // Пропускаем разделитель
		} else {
			// Если это не разделитель, продолжаем собирать текущую строку
			currentString += string(s[i])
		}
	}

	// Добавляем последнюю часть строки после последнего разделителя
	result = append(result, currentString)

	return result
}
```

---

## Ключевые понятия

| **Термин / инструмент** | **Объяснение** |
|--------------------------|----------------|
| **Переменные (`string`)** | вводные аргументы в типе данных *строк*. |
| **Срез (`[]string`)** | Структура данных в Go, динамический массив строк. Переменная где сохраняется вывод |
| **условия `if (sep == "")`** | Смотрит разделяющий как в скобках, то есть если нет разделител строк то дать как есть |
| **var currentString string** | Пременная для сохраннение исходной строки. |
| **цикл for с i < len(s)** | Перепирает по руне нашу строку. |
|**функция `append(slice, )`**| Мы через эту функцию добовляем в наш срез цифры по 1 до границы заданой по циклу |

---

## Логика и пошаговый разбор кода

### 1. Начало кода и его исходные данные

```go
package piscine

func Split(s, sep string) []string {
	if sep == "" {
		return []string{s}
	}

```
- Беря 2 строки выводим массив из несколько строк.
- Смотрит и сравнивает строку и если она пуста как и в сравнении то выводит без изменении

---

### 2. Создание среза

```go
    var result []string
    var currentString string
```
- `var` — через эту функцию создаем желаемую переменую в пустом формате
- [] и вид данных создает массив с ним а без него только 1 значение
---

### 3. Заполняем срез числами по порядку

```go
    for i := 0; i < len(s); i++ {
		if s[i:i+len(sep)] == sep {
			result = append(result, currentString)  
			currentString = ""  
			i += len(sep) - 1  
	}
```
- Цикл проходить по всей длине строки по руне.
- Индекс `i` увеличивается: 0, 1, 2, 3...
- Если в разрезе между индексом и 2 строке схожие с тем что указоно в `sep` то массиву добавляем то что сохранили до него убирая то что схож с *`sep`string* 
---
### 4. Выходим из цикла и возвращаем результат

```go
  	result = append(result, currentString)

    return result
```
- Добавляем последнии часть через append и выводим то что у нас получилось
---

## Заключение

Функция `Split` показывает, как работать со срезами и когда использовать `append`.  
Ты создашь свой срез, а затем заполняешь его так чтобы одна строка была разделено по очереди и правильно по задаче.  
Это задание помогает понять:  
- как создаются динамические массивы,  
- как работает функция `append()`,  
- зачем иногда нужны переменные ввиде var,
- как взаимодействовать элементами в строке и менять их как нам надо,
- почему важно написать код динамичным и понятным.
