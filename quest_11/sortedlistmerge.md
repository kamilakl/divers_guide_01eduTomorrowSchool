# Quest 11.15 - SortedListMerge

## Название файла Go
`sortedlistmerge.go`

---

## Условия задания 

| **Instruction (eng)**                                                                 | **Перевод (ru)**                                                                    |
| ------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| Write a function `SortedListMerge` that merges two sorted linked lists into one.     | Написать функцию `SortedListMerge`, которая объединяет два отсортированных списка в один. |

---

Функция принимает указатели на головы двух отсортированных односвязных списков `n1` и `n2`.  
Необходимо объединить их в один отсортированный по возрастанию список.  
Функция возвращает голову нового списка.

### Пример

Исходные списки:

```go
n1: 3 -> 5 -> 7 -> nil
n2: -2 -> 9 -> nil
```


После слияния:

```go
-2 -> 3 -> 5 -> 7 -> 9 -> nil
```


---

## Решение

**Вы уже определили структуру `NodeI` в упражнении `listsort`.**

```go
package piscine

func SortedListMerge(n1 *NodeI, n2 *NodeI) *NodeI {
    dummy := &NodeI{}       
    current := dummy        

    for n1 != nil && n2 != nil {
        if n1.Data <= n2.Data {
            current.Next = n1
            n1 = n1.Next
        } else {
            current.Next = n2
            n2 = n2.Next
        }
        current = current.Next
    }

    if n1 != nil {
        current.Next = n1
    } else if n2 != nil {
        current.Next = n2
    }

    return dummy.Next
}
```

---

## Ключевые понятия

| **Термин / элемент кода**     | **Объяснение**                                                                                                                                       |
| ----------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Список (List)**             | Структура данных, состоящая из последовательности элементов (узлов), каждый из которых содержит данные и ссылку на следующий элемент.                |
| **Узел (Node / NodeI)**       | Элемент списка, который хранит данные (`Data`) и указатель на следующий узел (`Next`).                                                               |
| **Head (голова списка)**      | Первый элемент списка. С него начинается обход всех узлов.                                                                                           |
| **Tail (хвост списка)**       | Последний элемент списка. Его поле `Next` всегда `nil`.                                                                                              |
| **Next**                      | Ссылка на следующий элемент узла.                                                                                                                    |
| **Data**                      | Данные, хранящиеся в узле.                                                                                                                           |
| **Указатель (`*`) / Pointer** | Переменная, которая хранит **адрес** другого значения. Используется для того, чтобы функция могла изменять структуру списка напрямую, а не её копию. |
| **Итерация по списку**        | Движение по узлам через `Next`.                                                                                                                      |
| **Merge**                     | Объединение двух отсортированных списков в один, сохраняя порядок.                                                                                   |
| **O(n + m)**                  | Временная сложность слияния двух списков длины n и m соответственно.                                                                                 |
| **nil**                       | Конец списка.                                                                                                                                        |

---

## Логика и пошаговый разбор кода

### 1. Объявление функции

```go
func SortedListMerge(n1 *NodeI, n2 *NodeI) *NodeI {
```
Эта строка объявляет функцию **SortedListMerge**, которая принимает:
- `n1 *NodeI` — указатель на голову первого отсортированного списка
- `n2 *NodeI` — указатель на голову второго отсортированного списка
- Возвращает голову объединённого отсортированного списка


### 2. Создание вспомогательного узла

```go
dummy := &NodeI{}
current := dummy
```

- `dummy` — временный узел, который упрощает операции с указателями.
- `current` будет указывать на последний элемент нового списка.

### 3. Основной цикл слияния

```go
for n1 != nil && n2 != nil {
    if n1.Data <= n2.Data {
        current.Next = n1
        n1 = n1.Next
    } else {
        current.Next = n2
        n2 = n2.Next
    }
    current = current.Next
}
```

- Сравниваем текущие элементы двух списков.
- Меньший элемент присоединяем к `current.Next`.
- Двигаем `current` вперёд, а выбранный список тоже продвигаем. 
- Продолжаем, пока оба списка не будут полностью пройдены.

### 4. Добавление остатка списка

```go
if n1 != nil {
    current.Next = n1
} else if n2 != nil {
    current.Next = n2
}
```

- Если один список закончился раньше другого, присоединяем оставшиеся элементы.

### 5. Возврат головы объединённого списка

```go
return dummy.Next
```

- `dummy.Next` указывает на реальную голову нового списка, пропуская вспомогательный узел.

### Пошаговый пример

Исходные списки:

```go
n1: 3 -> 5 -> 7 -> nil
n2: -2 -> 9 -> nil
```

| Шаг | Действие                      | Состояние объединённого списка |
| --- | ----------------------------- | ------------------------------ |
| 1   | `-2 < 3` → добавляем из n2    | -2 -> nil                      |
| 2   | `3 < 9` → добавляем из n1     | -2 -> 3 -> nil                 |
| 3   | `5 < 9` → добавляем из n1     | -2 -> 3 -> 5 -> nil            |
| 4   | `7 < 9` → добавляем из n1     | -2 -> 3 -> 5 -> 7 -> nil       |
| 5   | n1 пуст, добавляем остаток n2 | -2 -> 3 -> 5 -> 7 -> 9 -> nil  |


---

## Заключение

- `SortedListMerge` объединяет два отсортированных списка за один проход.
- Сложность алгоритма **O(n + m)**, где **n** и **m** — длины списков.
- Использование указателей позволяет соединять списки без создания новых узлов.
- Список остаётся отсортированным после слияния.
