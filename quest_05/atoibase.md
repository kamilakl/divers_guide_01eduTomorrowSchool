# Quest 5.21 Atoi Base

## Название файла Go
`atoibase.go`

---

## Условия задания 

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| Write a function that takes two arguments: | Написать функцию, которая принимает два аргумента: |
| `s`: a numeric `string` in a given base. | `s`: строка-число, записанная в некоторой системе счисления. |
| `base`: a `string` representing all the different digits that can represent a numeric value. | `base`: `строка`, содержащая все символы (цифры) данной системы счисления. |
| And return the integer value of `s` in the given `base`. | И вернуть целочисленное значение строки `s`, интерпретируя её в этой системе. |
| If the base is not valid it returns `0`. | Если база недействительна — вернуть `0`. |
| Validity rules for a base: | Правила валидности базы: |
| A base must contain at least 2 characters. | База должна содержать минимум 2 уникальных символа. |
| Each character of a base must be unique. | Все символы в базе должны быть уникальны. |
| A base should not contain `+` or `-` characters. | База не должна содержать символы `+` или `-`. |
| String number must contain only elements that are in base. | Число `s` должно состоять только из символов присутствующих в базе. |
| Only valid `string` numbers will be tested. | На вход будут подаваться только корректные строки-числа. |
| The function does not have to manage negative numbers. | Поддержка отрицательных чисел не требуется. |

---

### Что нужно сделать

Нужно написать функцию:

```go
func AtoiBase(s string, base string) int
```

Функция должна:

* проверить корректность базы;
* интерпретировать строку `s` как число в системе счисления `base`;
* вернуть его **десятичное значение** (`int`);
* вернуть **0**, если база недействительна.

---

### Пример

1. **Ввод:**
   `AtoiBase("125", "0123456789")`
   **Вывод:**
   `125`

2. **Ввод:**
   `AtoiBase("1111101", "01")`
   **Вывод:**
   `125`

3. **Ввод:**
   `AtoiBase("7D", "0123456789ABCDEF")`
   **Вывод:**
   `125`

4. **Ввод:**
   `AtoiBase("uoi", "choumi")`
   **Вывод:**
   `125`

5. **Ввод:**
   `AtoiBase("bbbbbab", "-ab")`
   **Вывод:**
   `0` (некорректная база)

---

## Решение

```go
package piscine

// AtoiBase — конвертирует строку s, записанную в системе счисления base, в десятичное число.
func AtoiBase(s, base string) int {
	// Проверяем, что база корректная
	if !isValidBase(base) {
		return 0
	}

	result := 0
	baseLen := len(base)

	for i, char := range s {
		// Получаем индекс символа в базе
		digit := indexInBase(char, base)
		if digit == -1 {
			return 0 // символ отсутствует в базе → некорректный ввод
		}

		// Переводим позиционное значение: digit * base^(позиция)
		power := len(s) - 1 - i
		result += digit * RecursivePower(baseLen, power)
	}

	return result
}

// isValidBase проверяет, что база корректна:
// - длина не меньше 2
// - нет повторяющихся символов
// - нет символов '+' или '-'
func isValidBase(base string) bool {
	if len(base) < 2 {
		return false
	}

	seen := make(map[rune]bool)

	for _, ch := range base {
		// '+' и '-' нельзя использовать в системе счисления
		if ch == '+' || ch == '-' {
			return false
		}
		// проверка на повтор
		if seen[ch] {
			return false
		}
		seen[ch] = true
	}

	return true
}

// indexInBase возвращает индекс символа в строке base,
// или -1, если символ отсутствует
func indexInBase(ch rune, base string) int {
	for i, b := range base {
		if b == ch {
			return i
		}
	}
	return -1
}
```

---

## Ключевые понятия

| **Инструмент / элемент кода** | **Объяснение и назначение** |
|-------------------------------|------------------------------|
| **Пакет (`package piscine`)** | Определяет принадлежность файла к пакету `piscine`. Позволяет использовать функцию `AtoiBase` в других файлах этого пакета. |
| **Функция (`func AtoiBase(s, base string) int`)** | Основная функция, которая принимает строку-число `s` и строку базы `base`, возвращает **десятичное значение числа** или **`0`** при некорректной базе. |
| **Внешняя функция `RecursivePower`** | Используется для возведения числа в степень. Эта функция была создана в 4-м квесте ([см. ссылку на задание](../quest_04/recursivepower.md)). *Примечания: обязательно реализована в пакете или можно заменить на быстрый цикл* |
| **Вспомогательная функция `isValidBase(base string) bool`** | Проверяет корректность базы: **длина ≥ 2**, нет `'+'` или `'-'`, все символы **уникальны**. |
| **Вспомогательная функция `indexInBase(ch rune, base string) int`** | Находит индекс символа в базе. **Индекс соответствует его значению в данной системе.** Возвращает `-1`, если символ не найден. |
| **Цикл `for i, char := range s`** | Проходит по всем символам строки числа `s`, начиная с старшего разряда. |
| **Переменная `digit`** | Индекс символа в базе, который является его числовым значением. |
| **Позиционное значение (`digit * base^power`)** | Формула перевода числа из произвольной базы в десятичную. `power` = позиция цифры от младшего к старшему разряду. |
| **`return result`** | Возвращает окончательный результат конвертации числа в десятичную систему. |

---

## Логика и пошаговый разбор кода

### 1. Проверка валидности базы

Перед обработкой числа выполняются проверки:

```go
if !isValidBase(base) {
    return 0
}
```

База считается корректной, если:

1. **её длина ≥ 2**
2. **нет повторяющихся символов**
3. **нет `+` и `-`**

Это контролирует функция:

```go
func isValidBase(base string) bool { ... }
```

Почему важно:
Если база неверная — преобразование не имеет смысла, поэтому возвращаем 0.

---

### 2. Подготовка к переводу

```go
result := 0
baseLen := len(base)
```

* `result` — здесь накапливается итоговое десятичное число.
* `baseLen` — основание системы счисления (например, `"01"` → 2, `"0123456789ABCDEF"` → 16, `"choumi"` → 6).

---

### 3. Цикл: перебор каждой “цифры” строки `s`

```go
for i, char := range s {
```

Здесь мы проходим строку слева направо (от старших разрядов к младшим).

Для каждого символа выполняется 3 шага:


### 3.1. Находим числовой эквивалент символа

```go
digit := indexInBase(char, base)
```

Функция:

```go
func indexInBase(ch rune, base string) int
```

возвращает позицию символа в базе:

| base           | char  | digit |
| -------------- | ----- | ----- |
| `"0123456789"` | `'7'` | 7     |
| `"choumi"`     | `'u'` | 3     |
| `"01"`         | `'1'` | 1     |

Если символ не найден — возвращаем `0`, но по условию задачи такие кейсы не тестируются.


### 3.2. Определяем степень основания

```go
power := len(s) - 1 - i
```

Для примера `"uoi"`:

| i | char | power |
| - | ---- | ----- |
| 0 | 'u'  | 2     |
| 1 | 'o'  | 1     |
| 2 | 'i'  | 0     |

Это стандартная позиционная система:

```
u  o  i
↓  ↓  ↓
base^2  base^1  base^0
```


### 3.3. Переводим разряд и добавляем к результату

```go
result += digit * RecursivePower(baseLen, power)
```

Смысл формулы:

```
значение_цифры × (основание ^ позиция)
```

То же самое происходит в десятичной системе:

```
125 = 1×10² + 2×10¹ + 5×10⁰
```

---

### 4 Функция `isValidBase()`

```go
func isValidBase(base string) bool {
```

* Объявление функции `isValidBase`.
* Принимает строку `base` — набор символов системы счисления.
* Возвращает `bool` — `true`, если база корректна, `false` иначе.

```go
	if len(base) < 2 {
		return false
	}
```

* Сначала проверяем длину базы.
* Если в базе меньше 2 символов, система счисления некорректна → возвращаем `false`.
* Пример: `"0"` → недопустимо.

```go
	seen := make(map[rune]bool)
```

* Создаём словарь `seen` для отслеживания символов, которые уже встречались.
* Ключ — `rune` (символ Unicode), значение — `bool`.
* Используем для проверки повторяющихся символов.

```go
	for _, ch := range base {
```

* Проходим по каждому символу `ch` в строке `base`.
* `_` — индекс нам не нужен, поэтому опускаем.

```go
		if ch == '+' || ch == '-' {
			return false
		}
```

* Если символ `+` или `-`, база недопустима → возвращаем `false`.

```go
		if seen[ch] {
			return false
		}
```

* Проверяем, встречался ли символ ранее.
* Если да, база недопустима → возвращаем `false`.

```go
		seen[ch] = true
```

* Если символ ещё не встречался, отмечаем его как встреченный.

```go
	return true
}
```

* Если цикл завершился и проблем не найдено → база корректна, возвращаем `true`.

**Пример работы:**

```go
isValidBase("0123456789")   // true
isValidBase("01+2")         // false
isValidBase("1123")         // false
isValidBase("0")            // false
```

---

### 5. Функция `indexInBase()`

```go
func indexInBase(ch rune, base string) int {
```

* Объявление функции `indexInBase`.
* Принимает символ `ch` и строку базы `base`.
* Возвращает `int` — индекс символа в базе.
* Если символ отсутствует в базе, возвращает `-1`.

```go
	for i, b := range base {
```

* Проходим по каждому символу `b` в строке `base`.
* `i` — индекс текущего символа.

```go
		if b == ch {
			return i
		}
```

* Сравниваем текущий символ базы `b` с искомым символом `ch`.
* Если совпадают — возвращаем индекс `i`.
* Пример: `indexInBase('A', "0123456789ABCDEF")` → `10`.

```go
	return -1
}
```

* Если символ не найден после прохода по всей базе → возвращаем `-1`.
* В основной функции это сигнал о некорректном символе числа.

**Пример работы:**

```go
indexInBase('o', "choumi")  // 2
indexInBase('x', "choumi")  // -1
```

---

### 6. Завершение работы

```go
return result
```

К этому моменту `result` содержит полноценное десятичное число.

---

## Мини-пример полного прохода

(`s = "uoi"`, `base = "choumi"`)

| Шаг | char | digit | power | calc         |
| --- | ---- | ----- | ----- | ------------ |
| 1   | `u`  | 3     | 2     | 3 × 6² = 108 |
| 2   | `o`  | 2     | 1     | 2 × 6¹ = 12  |
| 3   | `i`  | 5     | 0     | 5 × 6⁰ = 5   |

**108 + 12 + 5 = 125**

---

## Глоссарий

| **Термин** | **Понятное объяснение** |
|-------------|--------------------------|
| **База (base)** | Набор уникальных символов, которые используются для записи числа в данной системе счисления. |
| **Старший разряд (most significant digit)** | Символ числа, который находится в начале строки и имеет наибольший вес при переводе в десятичное число. *Например, в числе "125" в десятичной системе старший разряд — '1', его значение = 1×10² = 100.* |
| **Младший разряд (least significant digit)** | Символ числа, который находится в конце строки и имеет наименьший вес. *Например, в числе "125" младший разряд — '5', его значение = 5×10⁰ = 5.* |
| **Рекурсивная степень (`RecursivePower`)** | Функция, которая вычисляет base^power для перевода позиции цифры в десятичное значение. |
| **Результат (result)** | Переменная, в которой суммируются все значения разрядов, чтобы получить итоговое десятичное число. |
| **Rune** | Тип данных для одного символа Unicode. Используется для работы с символами строки и базы. |
| **Некорректная база** | База, которая имеет меньше двух символов, содержит '+' или '-', либо повторяющиеся символы. В этом случае функция возвращает 0. |

---

## Test cases

| **Ввод (s, base)**                  | **Вывод** | **Пояснение**                                                                                                                    |
| ----------------------------------- | --------- | -------------------------------------------------------------------------------------------------------------------------------- |
| `"125", "0123456789"`               | `125`     | Обычное десятичное число.                                                                                                        |
| `"1111101", "01"`                   | `125`     | Бинарное → 125.                                                                                                                  |
| `"7D", "0123456789ABCDEF"`          | `125`     | Hex → 125 (7 = 7×16, D = 13).                                                                                                    |
| `"uoi", "choumi"`                   | `125`     | `c=0 h=1 o=2 u=3 m=4 i=5`, значит: `u(3)*6² + o(2)*6¹ + i(5)*6⁰ = 108 + 12 + 5 = 125`.                                           |
| `"bbbbbab", "ab"`                   | `0`       | Бинарное `1111101` → `125`                                                   |
| `"AAAA", "ABCDEF"`                  | `0`       | Символ `'A'` в верхнем регистре не совпадает с `'A'`? Строка ок, но `'A'` есть только 1 раз, индексы все равны 0, результат = 0. |
| `"aaaa", "abcd"`                    | `0`       | Все цифры индекс 0 → число = 0.                                                                                                  |
| `"c", "choumi"`                     | `0`       | `'c'` — первый символ базы → индекс 0.                                                                                           |
| `"1", "1"`                          | `0`       | База из 1 символа — невалидная.                                                                                                  |
| `"10", "01"`                        | `2`       | Бинарное число `"10"` → 2.                                                                                                       |
| `"ba", "ab"`                        | `2`       | Индексы: b=1, a=0 → 1×2¹ + 0 = 2.                                                                                                |
| `"ab", "ab"`                        | `1`       | a=0, b=1 → 0×2¹ + 1 = 1.                                                                                                         |
| `"ff", "0123456789abcdef"`          | `255`     | Классический hex.                                                                                                                |
| `"z", "abcdefghijklmnopqrstuvwxyz"` | `25`      | Индекс `'z'` = 25.                                                                                                               |
| `"aaa", "a+"`                       | `0`       | Невалидная база (содержит '+').                                                                                                  |
| `"bbb", "--ab"`                     | `0`       | Невалидная база (содержит '-').                                                                                                  |
| `"123", "01234"`                    | `38`      | 1×5² + 2×5¹ + 3×5⁰ = 25 + 10 + 3.                                                                                                |

---

## Заключение

В этом задании важно понять, **как строка, записанная в произвольной системе счисления, превращается в обычное десятичное число.**

Главные моменты, которые нужно запомнить:
- **Корректность базы — основа всего**: не меньше 2 символов, нет повторов, нет + и -.
- **Каждый символ имеет “цену” — свой индекс в базе.**
- **Старшие разряды дают больший вклад**, потому что умножаются на более высокую степень основания.
- **Перевод в десятичную систему — это сумма**: `digit * base^position` **для каждой позиции**.
- Вспомогательные функции (`isValidBase`, `indexInBase`) делают код чище и понятнее.

Если понятно, **как “взвешивается” каждый символ**, — задача полностью раскрыта.