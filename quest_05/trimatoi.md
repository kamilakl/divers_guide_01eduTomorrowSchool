# Quest 5.16 TrimAtoi
**Автор разбора:** aigsadykova

## Название файла Go
`trimatoi.go`  

---

## Условия задания

| **Instruction** | **Перевод** |
|-----------------|-------------|
| Write a function that transforms numbers within a string into an int. If the `-` sign is encountered before any number it should determine the sign of the returned int. This function should only return an `int`. In the case of an invalid input, the function should return `0`. Only one sign will appear in the tests. | Написать функцию, которая извлекает число из строки и возвращает `int`. Если перед числом встречается `-`, он определяет знак результата. Если в строке нет цифр — вернуть `0`. В тестах не будет более одного знака. |

---

Нужно написать функцию, которая:
- находит цифры внутри строки и собирает из них число,
- учитывает знак `-`, если он встречается *до первой цифры*,
- игнорирует любые другие символы,
- возвращает `0`, если в строке нет цифр.

---

### Пример

**Ввод → Вывод**
```
TrimAtoi("12345")           → 12345
TrimAtoi("str123ing45")     → 12345
TrimAtoi("012 345")         → 12345
TrimAtoi("Hello World!")    → 0
TrimAtoi("sd+x1fa2W3s4")    → 1234
TrimAtoi("sd-x1fa2W3s4")    → -1234
TrimAtoi("sdx1-fa2W3s4")    → 1234
TrimAtoi("sdx1+fa2W3s4")    → 1234
```

---

## Решение

```go
package piscine

func TrimAtoi(s string) int {
	sign := 1
	num := 0
	foundDigit := false

	for i := 0; i < len(s); i++ {
		char := s[i]

		if char == '-' && !foundDigit {
			sign = -1
		}

		if char >= '0' && char <= '9' {
			num = num*10 + int(char-'0')
			foundDigit = true
		}
	}

	return num * sign
}
```

---

## Ключевые понятия

| **Термин или инструмент** | **Объяснение** |
|--------|------------|
| **ASCII** | Кодировка, где цифры и `-` имеют фиксированные байтовые значения. |
| **char - '0'** | Операция преобразующая символ цифры в число (например, `'7' - '0' = 7`). |
| **Итерация** | Один проход цикла (чтение одного символа). |
| **char := s[i]** | Байтовая обработка - берем символ строки по индексу. Подходит, потому что мы работаем с ASCII-символами: `'-'` и `'0'..'9'` где один символ равен 1 байт. |

---

## Логика и пошаговый разбор кода

### 1. Инициализация переменных
```go
package piscine

func TrimAtoi(s string) int {
    sign := 1
    num := 0
    foundDigit := false
```
- `sign = 1` — предполагаем число положительным;  
- `num = 0` — ещё не собрано ни одной цифры;  
- `foundDigit = false` — пока не встретили цифр.

---

### 2. Проход по строке
```go
    for i := 0; i < len(s); i++ {
	    char := s[i]
	    ...
```
Читаем строку по байтам: `s[0]`, `s[1]`, ... Для нашей цели (цифры и `-`) достаточно байтов.

---
### 3. Проверка знака `-` (только до первой цифры)
```go
        if char == '-' && !foundDigit {
	        sign = -1
        }
```
Если `-` встретился до первой цифры — установим `sign = -1`. 
Минус после начала числа игнорируем, поэтому должно выполниться условие где `founddigit` является `false` (`!foundigit`)

---

### 4. Нахождение и сбор цифр
```go
        if char >= '0' && char <= '9' {
	        num = num*10 + int(char-'0')
	        foundDigit = true
        }
```
- `char - '0'` превращает символ в число;  
- `num = num*10 + digit` собирает число справа налево;  
- `foundDigit = true` помечает, что число началось.

Каждый раз, когда встречается новая цифра, предыдущие цифры нужно "сдвинуть влево", чтобы освободить место для новой справа
Это делается умножением `num*10`. Затем `char - '0'` превращает символ `'0'..'9'` в число `0..9`. Складывая их (`num*10 + digit`), мы добавляем цифру в конец числа. 
Например: `'4'` → num = 4, 
затем `'2'` → num = 4*10+2 = 42, 
затем `'7'` → num = 42*10+7 = 427. Таким образом цифры собираются строго в том порядке, в котором встречаются в строке.

---

### 5. Возврат результата
```go
    return num * sign
```
Если цифр не было — `num == 0` → возвращаем `0`. Иначе возвращаем собранное число со знаком.

---

## Пошаговая демонстрация

Строка: **`"sd-x1fa2W3s4"`**

| Индекс | Символ | foundDigit | Действие | num | sign |
|--------|--------|------------|----------|-----|------|
| 0 | s | false | не цифра | 0 | 1 |
| 1 | d | false | не цифра | 0 | 1 |
| 2 | - | false | до цифры → sign = -1 | 0 | -1 |
| 3 | x | false | не цифра | 0 | -1 |
| 4 | 1 | true | num = 1 | 1 | -1 |
| 5 | f | true | не цифра | 1 | -1 |
| 6 | a | true | не цифра | 1 | -1 |
| 7 | 2 | true | num = 12 | 12 | -1 |
| 8 | W | true | не цифра | 12 | -1 |
| 9 | 3 | true | num = 123 | 123 | -1 |
|10 | s | true | не цифра | 123 | -1 |
|11 | 4 | true | num = 1234 | 1234 | -1 |

Результат: `num = 1234`, `sign = -1` → `-1234`.

---

## Дополнительные примеры и объяснения

- `"str123ing45"` → `12345` (все цифры объединяются в порядке появления).  
- `"012 345"` → `12345` (пробел игнорируется; ведущие нули не меняют итог).  
- `"Hello World!"` → `0` (нет цифр).  
- `"sdx1-fa2W3s4"` → `1234` (минус после первой цифры игнорируется).  
- `+` не обрабатывается как знак в этой реализации (он просто игнорируется как нецифра); в тестах гарантирован максимум один знак.

---

## Заключение

Функция полезна для парсинга пользовательского ввода и очистки строк перед числовой обработкой. 

Обратите внимание: 
- на пользу, синтаксис и назначение булевых переменных (как foundigit);
- на разницу между итерацией по рунам или байтам.