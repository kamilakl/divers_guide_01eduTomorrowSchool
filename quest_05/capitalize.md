# Quest 5.17 Capitalize

## Название файла Go
`capitalize.go`

---

## Условия задания

| **Instruction** | **Перевод** |
|-----------------|-------------|
| Write a function that capitalizes the first letter of each word and makes the rest lowercase. | Напишите функцию, которая делает первую букву каждого слова заглавной, а остальные — строчными. |

---

Нужно написать функцию, которая:
- определяет границы слов (буквы и цифры являются частью слова),
- первую букву каждого слова делает заглавной,
- остальные буквы внутри слова делает строчными,
- все другие символы (пробел, знак, пунктуация) *не меняет* и считает разделителями слов.

---

### Пример

- **Ввод:**
  ```go
  fmt.Println(piscine.Capitalize("hello, how ARE you? 42words forty-two"))
  ```
- **Вывод:**
  ```
  Hello, How Are You? 42words Forty-Two
  ```

---

## Решение

```go
package piscine

func Capitalize(s string) string {
    result := []byte(s)
    isNewWord := true

    for i := 0; i < len(result); i++ {
        c := result[i]

        // Если символ буква или цифра → часть слова
        if (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') {

            // Если это первая буква слова — делаем заглавной
            if isNewWord && c >= 'a' && c <= 'z' {
                result[i] -= 'a' - 'A'
            }

            // Если НЕ первая буква слова — делаем строчной
            if !isNewWord && c >= 'A' && c <= 'Z' {
                result[i] += 'a' - 'A'
            }

            isNewWord = false
        } else {
            // Любой не-алфанумерический символ завершает слово
            isNewWord = true
        }
    }

    return string(result)
}
```

---

## Ключевые понятия

| **Элемент** | **Пояснение** |
|-------------|----------------|
| **`[]byte`** | Преобразование строки в массив байтов, чтобы можно было изменять символы (строки в Go неизменяемы: immutable). |
| **ASCII-коды** | `'A'`–`'Z'` и `'a'`–`'z'` имеют разницу 32, что позволяет переводить символы между регистрами простым сложением/вычитанием. |
| **`isNewWord`** | Флаг, который показывает: следующий алфанумерический символ это первая буква нового слова. |
| **Разделители слов** | Всё, что не буквы и не цифры — считается границей слова. |

---

## Логика и пошаговый разбор кода

### 1. Преобразование строки в `[]byte`
Строки в Go нельзя изменять. Поэтому мы превращаем строку в массив байтов:

```go
package piscine

func Capitalize(s string) string {
    result := []byte(s)
```
Теперь каждый символ можно менять напрямую.

### 2. Флаг `isNewWord`
```go
    isNewWord := true
```
Он указывает, что следующий алфанумерический символ должен стать заглавным.  
Изначально начало строки = начало слова.

### 3. Цикл по символам строки
```go
    for i := 0; i < len(result); i++ {
        c := result[i]
```
Мы обрабатываем каждый символ `c`, определяя:
- это начало слова?
- это середина слова?
- это разделитель?

### 4. Проверка: буква/цифра или разделитель
```go
        if (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') {
```
Если символ это буква или цифра то он часть слова. Далее заходим в следующее условие и смотрим, первая ли это буква
Иначе слово не начиналось, мы все еще ждем что следующий символ начнет слово (`isNewWord = true` в `else`).


### 5. Преобразования регистра

#### 5.1. Если это начало слова и оно в нижнем регистре, делаем символ заглавным
```go
            if isNewWord && c >= 'a' && c <= 'z' {
                result[i] -= 'a' - 'A'
        }
```
Разница `'a' - 'A'` = **32**, поэтому `'m' - 32 = 'M'`.

---
#### 5.2. Если мы сейчас в середине слова то делаем строчным
```go
            if !isNewWord && c >= 'A' && c <= 'Z' {
                result[i] += 'a' - 'A'
        }
```
Так мы избавляемся от случайных заглавных букв в середине слов.

### 6. После прогона символа через эти условия:
Если наш символ выполнил наше первое главное условие (это или заглавная\строчная буква или цифра), меняем флаг:
```go
        isNewWord = false
```
Ставим флаг firstChar в false потому что теперь мы уже натыкались на какие-то буквы/цифры, следовательно мы внутри слова (следующие символы не первые)

### 6. Обработка разделителей
Если символ не буква и не цифра:
```go
        } else {
        // Любой не-алфанумерический символ завершает слово
            isNewWord = true
        }
```
Следующий символ снова будет первым в слове.

### 7. Закрывается цикл, возвращаем строку в которую собирали символы
```go
    }
    return string(result)
}
```
---

### Короткая итерация работы алгоритма

Возьмём строку:
```
"hello, world"
```
Идём по символам:

1. `h` — начало слова (`isNewWord = true`) → делаем `H`, теперь `isNewWord = false`
2. `e` — внутри слова → остаётся `e`
3. `l` — внутри слова → `l`
4. `l` — внутри слова → `l`
5. `o` — внутри слова → `o`
6. `,` — разделитель → `isNewWord = true`
7. ` ` — разделитель → `isNewWord = true`
8. `w` — начало нового слова → `W`, теперь `isNewWord = false`
9. `o` — внутри слова → `o`
10. `r` — внутри слова → `r`
11. `l` — внутри слова → `l`
12. `d` — внутри слова → `d`

**Результат:**
```
Hello, World
```
После буквы/цифры `isNewWord = false`  
После любого другого символа `isNewWord = true` 

---

## Заключение

Функция `Capitalize` важна, потому что учит:
- работать с кодировкой ASCII,
- различать буквы, цифры и разделители,
- правильно определять границы слов,
- менять регистры символов вручную,
- использовать флаг для отслеживания состояния (начало/середина слова),
- преобразовывать строку в байтовый массив для изменения символов.

Эти навыки встречаются в задачах на текстовую обработку, парсинг, нормализацию данных и написание собственных утилит форматирования.
