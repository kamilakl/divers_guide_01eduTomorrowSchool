# Quest 6.3 Reverse Params

## Название файла Go
`revparams/main.go`

---

## Условия задания 

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| Write a program that prints the arguments received in the command line in reverse order. | Напишите программу, которая выводит аргументы командной строки **в обратном порядке**. |

---

### Пример

Ввод:
```bash
$ go run . choumi is the best cat
```

Вывод:
```
cat
best
the
is
choumi
```

---

## Решение

```go
package main

import (
	"os"
	"github.com/01-edu/z01"
)

func main() {
	if len(os.Args) > 1 {
		for i := len(os.Args) - 1; i > 0; i-- {
			for _, r := range os.Args[i] {
				z01.PrintRune(r)
			}
			z01.PrintRune('\n')
		}
	}
}
```

---

## Ключевые понятия

| Инструмент | Объяснение |
|-----------|------------|
| **os** | Это стандартный пакет Go, который предоставляет функции для работы с операционной системой: файлы, процессы, аргументы командной строки и т.д. Нам нужен `os.Args`, чтобы получить список аргументов запуска программы. |
| **os.Args** | Срез строк — все аргументы, переданные программе. `os.Args[0]` — имя программы, `os.Args[1:]` — реальные аргументы. |
| **len(os.Args)** | Возвращает количество аргументов. |
| **Обратный цикл for i := len(...) - 1** | Перебирает аргументы с конца к началу. |
| **range по строке** | Корректный перебор каждого Unicode-символа (буквы, emoji, кириллица). |

---

## Логика и пошаговый разбор кода

### 1. Понимаем, что такое os.Args

`os.Args` это **список строк**, который формируется операционной системой, когда мы запускаем программу.

Например при запуске:

```bash
go run . a b c
```
`os.Args` будет:

| Индекс | Значение |
|--------|----------|
| 0 | путь к программе |
| 1 | "a" |
| 2 | "b" |
| 3 | "c" |

То есть **os.Args — мост между программой Go и терминалом**.

---

### 2. Проверка наличия аргументов

```go
package main

import (
	"os"
	"github.com/01-edu/z01"
)

func main() {
	if len(os.Args) > 1 {
```

Если аргументов нет (кроме имени программы) то выполнять и выводить нечего. Код не содержит явной проверки len(os.Args) == 1, но
условие if len(os.Args) > 1 уже гарантирует, что программа не войдет в цикл, и ничего не выведет если нет аргументов.

---

### 3. Цикл по аргументам в обратном порядке

```go
		for i := len(os.Args) - 1; i > 0; i-- {
```
- `len(os.Args) - 1` — индекс последнего аргумента
- `i > 0` — заканчиваем на `os.Args[1]`
- `i--` — идём назад по списку
---

### 4. Печать каждого аргумента посимвольно

```go
			for _, r := range os.Args[i] {
				z01.PrintRune(r)
}
```
Почему посимвольно?
- `PrintRune` печатает **только одну руну**
- Go-строка может быть в Unicode (напр. "Привет", "猫"), и `range` гарантирует корректный разбор символов.

---

### 5. Перенос строки после каждого аргумента

```go
			z01.PrintRune('\n')
```

Чтобы каждый аргумент печатался на новой строке, как требует тест.

---

## Заключение

Это задание учит:

- работать с аргументами командной строки  
- использовать стандартный пакет **os**  
- разбираться в структуре `os.Args`  
- печатать строки посимвольно через z01  
- использовать циклы и индексы  
- думать о порядке аргументов 
